#ifndef _TD_AUTH_H
#define _TD_AUTH_H

#include <cstdlib>
#include <vector>
#include <atomic>
#include <mutex>
#include <chrono>
#include <map>
#include <functional>
#include <atomic>
#include <chrono>
#include <iostream>

#include <td/telegram/Client.h>
#include <td/telegram/td_api.h>
#include <td/telegram/td_api.hpp>

#include "tg_focus_data.hh"

#include "tgfocus_state.hh"
extern std::vector<TgMsg> mq;
extern std::mutex mq_lock;
extern std::atomic<bool> is_csm_mq;
extern std::atomic<bool> is_tdlib_auth;
extern TgFocusData tf_data;
extern std::atomic<int> producer_hang_period;

namespace td_api = td::td_api;

// FIXME: concurrent login is way too complex.
//
// it seems that `receive` has some limitations, e.g, when we receive
// TdlibPara event from tdlib, if we somehow continue to `receive`, the next
// WaitPhone event a bit later, and just one time, which means we should
// save it, check it in each iteration afterward(meaning send request and
// check in its callback), it is quite complex, and what's more, tdlib seems
// restrict maximum number of user requests in specific period, hence, we
// here, leave this path as an alternative, and choose seperate interative
// binary for account login stuff.

class TdAuth
{
public:
  TdAuth () = default;

  //
  // initialize td client
  void init ()
  {
    td::ClientManager::execute (
      td_api::make_object<td_api::setLogVerbosityLevel> (3));
    client_manager_ = std::make_unique<td::ClientManager> ();
    client_id_ = client_manager_->create_client_id ();
    send_query (td_api::make_object<td_api::getOption> ("version"), {});
  }

  //
  // signal td client to fetch updates
  void handle_auth ()
  {
    auto response = client_manager_->receive (10);
    if (response.object)
      {
	std::cerr << "has resp\n";
	process_response (std::move (response));
      }
    else
      {
	std::cout << "no resp\n";
      }
  }

  bool is_authorized{false};
  bool is_login{false};

  void use_tfdata_phone ()
  {
    std::cerr << "use_tfdata_phone\n";

    send_query (td_api::make_object<td_api::setAuthenticationPhoneNumber> (
		  tf_data.get_phone (), nullptr),
		[this] (Object object) {
		  if (object->get_id () == td_api::error::ID)
		    {
		      auto error
			= td::move_tl_object_as<td_api::error> (object);
		      std::cerr << "phone err: " << to_string (error)
				<< std::endl;
		    }
		  else
		    {
		      std::cerr << "use_tfdata_phone callback : id "
				<< object->get_id () << std::endl;
		    }
		});
  }

private:
  using Object = td_api::object_ptr<td_api::Object>;
  std::unique_ptr<td::ClientManager> client_manager_; // client manager obj
  std::int32_t client_id_{0};			      // client id

  td_api::object_ptr<td_api::AuthorizationState> auth_state_;
  std::uint64_t current_query_id_{0}; // increase by each query
  std::uint64_t authentication_query_id_{0};

  std::map<std::uint64_t, std::function<void (Object)>> handlers_;

  void send_query (td_api::object_ptr<td_api::Function> f,
		   std::function<void (Object)> handler)
  {
    auto query_id = next_query_id ();
    if (handler)
      {
	handlers_.emplace (query_id, std::move (handler));
      }
    client_manager_->send (client_id_, query_id, std::move (f));
  }

  void process_response (td::ClientManager::Response response)
  {
    if (!response.object)
      return;
    if (response.request_id == 0)
      return process_update (std::move (response.object));
  }

  void process_update (td_api::object_ptr<td_api::Object> update)
  {
    using td::td_api::updateAuthorizationState;

    if (update->get_id () == td::td_api::updateAuthorizationState::ID)
      {
	auto casted = static_cast<updateAuthorizationState *> (update.get ());
	this->auth_state_ = std::move (casted->authorization_state_);
	this->on_authorization_state_update ();
      }
    else
      {
	std::cerr << "unknown update id " << update->get_id () << std::endl;
      }
  }

  auto create_authentication_query_handler ()
  {
    return [this, id = authentication_query_id_] (Object object) {
      if (object->get_id () == td_api::error::ID)
	{
	  auto error = td::move_tl_object_as<td_api::error> (object);
	  std::cout << "Error: " << to_string (error) << std::flush;
	  this->is_authorized = false;
	}

      // if (id == authentication_query_id_)
      // 	check_authentication_error (std::move (object));
    };
  }

  void on_authorization_state_update ()
  {
    this->authentication_query_id_++;

    switch (this->auth_state_->get_id ())
      {
	case td_api::authorizationStateReady::ID: {
	  this->is_authorized = true;
	  std::cout << "Authorization is completed" << std::endl;
	  is_tdlib_auth.store (true, std::memory_order_release);
	  break;
	}

	case td_api::authorizationStateLoggingOut::ID: {
	  this->is_authorized = false;
	  std::cout << "Logging out" << std::endl;
	  break;
	}

	case td_api::authorizationStateClosing::ID: {
	  std::cout << "Closing" << std::endl;
	  break;
	}

	case td_api::authorizationStateClosed::ID: {
	  is_authorized = false;
	  std::cout << "Terminated" << std::endl;
	  break;
	}

	case td_api::authorizationStateWaitPhoneNumber::ID: {
	  std::cout << "Enter phone number: " << std::flush;
	  need_phone.store (true, std::memory_order_release);
	  this->use_tfdata_phone ();
	  // std::string phone_number;
	  // std::cin >> phone_number;
	  // send_query (
	  //   td_api::make_object<td_api::setAuthenticationPhoneNumber> (
	  //     phone_number, nullptr),
	  //   create_authentication_query_handler ());
	  break;
	}

	case td_api::authorizationStateWaitEmailAddress::ID: {
	  std::cout << "Enter email address: " << std::flush;
	  std::string email_address;
	  std::cin >> email_address;
	  send_query (
	    td_api::make_object<td_api::setAuthenticationEmailAddress> (
	      email_address),
	    create_authentication_query_handler ());
	  break;
	}

	case td_api::authorizationStateWaitEmailCode::ID: {
	  std::cout << "Enter email authentication code: " << std::flush;
	  std::string code;
	  std::cin >> code;
	  send_query (
	    td_api::make_object<td_api::checkAuthenticationEmailCode> (
	      td_api::make_object<td_api::emailAddressAuthenticationCode> (
		code)),
	    create_authentication_query_handler ());
	  break;
	}

	case td_api::authorizationStateWaitCode::ID: {
	  std::cout << "Enter authentication code: " << std::flush;
	  std::string code;
	  std::cin >> code;
	  send_query (td_api::make_object<td_api::checkAuthenticationCode> (
			code),
		      create_authentication_query_handler ());
	  break;
	}

	case td_api::authorizationStateWaitRegistration::ID: {
	  std::string first_name;
	  std::string last_name;
	  std::cout << "Enter your first name: " << std::flush;
	  std::cin >> first_name;
	  std::cout << "Enter your last name: " << std::flush;
	  std::cin >> last_name;
	  send_query (td_api::make_object<td_api::registerUser> (first_name,
								 last_name),
		      create_authentication_query_handler ());
	  break;
	}

	case td_api::authorizationStateWaitPassword::ID: {
	  std::cout << "Enter authentication password: " << std::flush;
	  std::string password;
	  std::getline (std::cin, password);
	  send_query (td_api::make_object<td_api::checkAuthenticationPassword> (
			password),
		      create_authentication_query_handler ());
	  break;
	}

	case td_api::authorizationStateWaitOtherDeviceConfirmation::ID: {
	  auto casted = static_cast<
	    td_api::authorizationStateWaitOtherDeviceConfirmation *> (
	    this->auth_state_.get ());
	  std::cout << "Confirm this login link on another device: "
		    << casted->link_ << std::endl;
	  break;
	}

	case td_api::authorizationStateWaitTdlibParameters::ID: {
	  std::cerr << "wait tdlib para... " << std::endl;

	  std::string inbuf;

	  auto request = td_api::make_object<td_api::setTdlibParameters> ();
	  request->database_directory_ = tf_data.path_tddata ();
	  request->use_message_database_ = true;
	  request->use_secret_chats_ = true;
	  request->api_id_ = tf_data.get_api_id_as_int32 ();
	  request->api_hash_ = tf_data.get_api_hash (); //
	  request->system_language_code_ = "en";
	  request->device_model_ = "Desktop";
	  request->application_version_ = "1.0";
	  request->enable_storage_optimizer_ = true;
	  send_query (std::move (request),
		      create_authentication_query_handler ());
	  break;
	}

	default: {
	  std::cerr << "ignored auth state with id "
		    << this->auth_state_->get_id () << std::endl;
	  break;
	}
      }
  }

  void check_authentication_error (Object object)
  {
    if (object->get_id () == td_api::error::ID)
      {
	auto error = td::move_tl_object_as<td_api::error> (object);
	std::cout << "Error: " << to_string (error) << std::flush;
      }
  }

  //
  // td request id
  std::uint64_t next_query_id () { return ++current_query_id_; }
};

#endif
